---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# dynLM

<!-- badges: start -->
<!-- badges: end -->

The goal of dynLM is to provide a simple framework to make dynamic w-year risk predictions from landmark time points, allowing for competing risks and left and right censored data. 

## Installation

You can install the development version of dynLM from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("anyafries/dynLM")
```

## Example

This is a basic example which shows you how to use dynLM to make dynamic predictions and check calibration and discrimination metrics. First, we use the wide-form example data set given in the package. This gives the time-to-event of cancer relapse under 2 competing risks. 3 fixed patient bio-markers are given as well as the variable treatment which indicates the time at which the patient went off treatment.



```{R}
library(dynLM)

data(relapse)
head(relapse)
```

*Note: data can also be input in long-form. The only change is that later, the format argument to cutLMsuper will be given as "long".*

### Build a super data set

We first note the outcome variables we are interested in, as well as which variables are fixed or landmark-varying. In case there are no landmark-varying variables, set `varying=NULL`.

```{r vars}
outcome = list(time="Time", status="event")
covs = list(fixed=c("ID","age","marker1","marker2","marker3"),
            varying=c("treatment"))
```

We will produce 5-year dynamic predictions of relapse (`w`). Landmark time points (`LMs`) are set as every year between 0 and 3 years to train the model. 

We will consider constant and linear landmark interactions with the covariates (given in `func_covars`) and linear effects from the landmarks (`func_LMs`). The covariates that should have these landmark interactions are given in `LMcovars`.

```{r w}
w <- 5
LMs <- seq(0,3,by=1)

func_covars <- list(
  function(t) 1,
  function(t) t
  )
func_LMs <- list(
  function(t) t
)

LMcovars <- c("age","marker1","marker2","marker3","treatment")
```


With this, we are ready to build the super data set that will train the model. We print intermediate steps for illustration.
There are three steps: 

1. `cutLMsuper`: stacks the landmark data sets
2. An **optional** additional update for more complex columns that vary with landmark-times: For example, here we update the value of age. 
3. `addLMtime`: Landmark time interactions are added 

*Note that these return an object of class `LMdataframe`. This has an item `LMdata` which contains the dataset itself.* 

```{r super-data-set}
# Stack landmark datasets
LMdata <- cutLMsuper(relapse, outcome, LMs, w, covs, format="wide")
head(LMdata$LMdata)

# Update complex LM-varying covariates 
LMdata$LMdata$age <- LMdata$LMdata$age + LMdata$LMdata$LM
head(LMdata$LMdata)

# Add LM-time interactions
LMdata <- addLMtime(LMdata, LMcovars, func_covars, func_LMs)
head(LMdata$LMdata)
```

### Fit the super model

Now we can fit the model. We fit a model with all the covariates created. Note that `LMdata$allLMcovars` gives all the covariates with LM interaction

```{r fit-model}
model_covars <- LMdata$allLMcovars
print(model_covars)
```

```{r fit-super-model}
formula <- paste("Hist(Time, event, LM)", "~", 
                 paste(model_covars, collapse=" + "), "+ cluster(ID)")
supermodel <- fitLM(as.formula(formula), LMdata, "CSC") 
# supermodel
```

Dynamic hazard ratios can be plotted: 

```{r plot-dyn-HR}
par(mfrow=c(2,3))
plot_dynamic_HR(supermodel)
```

### Obtain predictions

#### For new data

A prediction is made for an individual at a specific prediction time (e.g., at baseline, at 2 years, etc). Thus both an individual and a prediction (landmark) time must be given.

New data is given as a dataframe with individual covariates associated with a landmark time point (i.e., covariate values set at the landmark time-point). E.g., this can be an entry from the very original data frame.

```{r}
ind = relapse[1:3,]
tLM = c(0,0,0)
p0 = predLMrisk(supermodel, ind, tLM, cause=1)
p0$preds
```


#### For the training data

Predictions for the training data can be obtained: 

```{r}
p1 = predLMrisk(supermodel)
```

We can observe calibration. Entering a named list of prediction objects from `predLMrisk` in the first argument allows for comparison between models.  

```{r quantile-calib}
method="quantile"
q=10 
YLIM=XLIM=c(0,0.2)

par(mfrow=c(2,2),pty="s")
outlist = LMcalPlot(list("sm"=p1), cause=1, method=method, q=q, ylim=YLIM, xlim=XLIM) 
```

Obtain the time-dependent Brier score and AUC for w-year prediction from landmarks: 

```{r LMScore}
scores = LMScore(list("LM"=p1), cause=1)
scores
```

### Visualize individual dynamic risk trajectories

Individual risk score trajectories can be plotted. As with `predLMrisk`, the data input is in the form of the original data. For example:

```{r}
idx <- c(1,15,294)
relapse[idx,]
```

We turn our data into long-form data to plot. 

*Note: we convert to long-form because of the age variable, wide-form data can be used too if there are no complex variables involved.*

```{r prep-long-data}
# Prediction time points
x = seq(0,3,by=0.05)

# Create long-form data to plot individual trajetory
dat = cutLMsuper(relapse[idx,],outcome, x, w, covs, format="wide")$LMdata
dat$age = dat$age+dat$LM

head(dat)
```

```{r plotRisk}
plotRisk(supermodel, dat,
            format="long", LM_col = "LM", id_col="ID", cause=1, ylim=c(0, 0.2))

```

